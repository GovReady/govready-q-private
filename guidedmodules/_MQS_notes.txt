MQS
===

Migrate Questions from being individual records to bein array in Module.

Benefits:

- Easier authoring by either just changing one Module record, or copying one Module record and bumping version.

Done
----

- File app_loading.py now retains the questions inside module.spec. When app is loaded, the question array still exists in Module.

- Add guidedmodules.models.Module.questions_set to return questions from Module.spec.

- Add guidedmodules.models.get_question_by_id to return question by id from Module.spec.


In Progress
-----------



CONTINUE HERE > - Have views.show_question retrieve the current answer if exists
    answer = taskq.get_current_answer()

    When Q does 'show_question', q value is passed in and q is type ModuleQuestion. But we are migrating away from ModuleQuestion.
    The module_question_id must be passed instead to get the question from Module.spec.question by matching on the question id.
    BUT, I don't understand how a whole question instance can be passed in a get URL? BECAUSE of the @task_view decorator, dammit!
    We need @task_view to not return ModuleQuestion: see 
        `question = get_object_or_404(ModuleQuestion, module=task.module, key=question_key)`

    to recover the current question answers the code calls `models.get_all_current_answer_records`

        questions = {question.id: question for question in
                     ModuleQuestion.objects.select_related('module').filter(
                         id__in=history.values_list('taskanswer__question_id', flat=True))}

- Have guidedmodules.views.get_next_question get next question from Module.spec.question array instead of list of Module.question.
    - The next question is determined as part of saving the answer.

- Add get_all_current_answer_records2(tasks) to get all TaskAnswers efficiently

- Editing a question saves in Module.spec.question.


TO DO
-----

- (general) Use Module.questions_set everywhere instead of relationship Module.questions to get questions.

- Editing question edits Module.spec.question

- What type of object should module.get_question_by_id return? dictionary object?

- Deleting question (optionally) bumps app version and adds new module record (to protect old version).

- Adding/Deleting modules bumps app version

- Make sure TaskAnswers are related/can be found by data in Module.spec.question instead of by Django ORM relationship to ModuleQuestion.

- Migrate Guidedmodules.models.ModuleQuestion back into guidedmodules.models.Module. Need to make sure any questionaires created witin application are now stored in Module.spec.question.

- Have models.Module.serialize Module.spec.question.
    Revise this section within code block:
    ```
    spec["questions"] = []
        for i, q in enumerate(self.questions.order_by('definition_order')):
            if i == 0 and q.key == "_introduction":
                spec["introduction"] = {"format": "markdown", "template": q.spec["prompt"]}
                continue
    ...
    ```

- Revise Module.questions_dependencies
    Use Module.spec.questions

- Delete guidedmodules.models.ModuleQuestion model.

- Remove instrumentation?



Areas
-----
app_loading - storing questions, they are already in module.spec
show_question
update question from authoring tool
walk questions
impute questions
serialize
serialize to download

TaskAnswer overhaul bc relationship would be on module.spec['question'].get_by_id

key vs id might be related to reassigning the name of a module in app.yaml

adding `key` and `definition_order` into Module.spec.questions

when starting module and creating tasks and task questions - views.new_task

taskanswer point back to question

I want to start using module.questions_set as replacement for module.questions

self.module.questions.get(key=question) needs to be self.module.questions_set.get_by_key(key=question) or get_by_id

Lines that need to change:
--------------------------
guidedmodules.views:  q = task.module.questions.get(id=request.POST.get("question"))
to change that file, I need to also send the module_question_id or question_key in the question form


    def redirect_to():

        # ==============================================
        # TEMPORARY TODO: FIX
        # TEMPORARY WHILE MOVE AWAY FROM ModuleQuestions
        return "/projects"
        # ==============================================

        next_q = get_next_question(q, task)
        if next_q:
            # Redirect to the next question.
            return task.get_absolute_url_to_question(next_q) + f"?back_url={back_url}&previous=nquestion"
        # Redirect to the module finished page because there are no more questions to answer.
        return task.get_absolute_url() + f"/finished?back_url={back_url}&previous=nquestion"



questions are already in Module.spec in module.spec['questions']; could leave them there.
But remeber to create as OrderedDict